"bioinformatics", "predictive models", "machine learning", "algorithms", "design",
"reporting", "genomic", "proteomic", "database management", "data safeguarding",
"collection", "interpretation", "epidemiology", "disease trends", "automation",
"capacity building", "mentorship", "dissemination", "publications", "workshops",
"research support", "ensemble modelling", "computational tools"
),
weight = c(55, 50, 48, 45, 44, 40, 38, 37, 36, 35, 34, 32, 30, 28, 27, 26, 25, 24, 23, 22, 21, 20, 18, 17, 15, 14, 13, 12, 11, 10),
stringsAsFactors = FALSE
)
# Create a vector of words and freqs
words <- keywords$word
freqs <- keywords$weight
names(freqs) <- words
# Save wordcloud to PNG with transparent background
wc_png <- "wc_raw.png"
png(filename = wc_png, width = 8000, height = 8000, bg = "transparent", res = 300)
par(mar = c(0, 0, 0, 0))
set.seed(123)
# scale: c(max_scale, min_scale) â€” adjust to increase font sizes
wordcloud(names(freqs),
freq = freqs, scale = c(6, 0.6),
min.freq = 1, random.order = FALSE, rot.per = 0.08,
use.r.layout = FALSE,
colors = brewer.pal(8, "Dark2")
)
dev.off()
# ------------------------------
# C. Composite wordcloud into Kenya mask using magick
#    Keep only the parts of the wordcloud that fall inside the white shape.
# ------------------------------
mask <- image_read(png_mask_path) # white shape on transparent
wc <- image_read(wc_png) # the transparent wordcloud
# Resize the wordcloud to match mask size (if needed)
mask_info <- image_info(mask)
wc_resized <- image_resize(wc, paste0(mask_info$width, "x", mask_info$height, "!"))
# Convert mask to a proper alpha mask: the white area of the mask should be opaque
# Create a grayscale mask where white=opaque, transparent=transparent
mask_gray <- image_convert(mask, colorspace = "gray")
# Use the mask to keep only the wordcloud pixels inside the shape.
# Operator "DstIn" keeps destination (wordcloud) where mask non-transparent
masked <- image_composite(wc_resized, mask_gray, operator = "DstIn")
# Optional: if you want the map outline as a subtle stroke behind words,
# create a faint black silhouette from the mask and composite under the masked wordcloud
silhouette <- image_fill(mask, "black", fuzz = 0) %>% image_transparent("white")
silhouette <- image_modulate(silhouette, brightness = 40) # dark subtle background
final <- image_composite(silhouette, masked, operator = "Over")
# Save final
image_write(final, "kenya_wordcloud_composite.png", format = "png")
# =====================================================================
# 0. Libraries
# =====================================================================
library(wordcloud)
library(RColorBrewer)
library(magick)
library(sf)
library(rnaturalearth)
# =====================================================================
# A. Kenya Mask (high-resolution, white fill, transparent background)
# =====================================================================
kenya <- ne_countries(
country = "Kenya",
scale = "medium",
returnclass = "sf"
)
png_mask_path <- "kenya_mask_inverted.png"
png(filename = png_mask_path,
width = 8000, height = 8000,
bg = "transparent", res = 600)
par(mar = c(0,0,0,0))
plot(st_geometry(kenya),
col = "white", border = NA, axes = FALSE)
dev.off()
# =====================================================================
# B. Word Data
# =====================================================================
keywords <- data.frame(
word = c(
"DSAS", "data", "analysis", "biostatistics", "modelling", "monitoring",
"evaluation", "bioinformatics", "predictive models", "machine learning",
"algorithms", "design", "reporting", "genomic", "proteomic",
"database management", "data safeguarding", "collection",
"interpretation", "epidemiology", "disease trends", "automation",
"capacity building", "mentorship", "dissemination", "publications",
"workshops", "research support", "ensemble modelling",
"computational tools"
),
weight = c(55, 50, 48, 45, 44, 40, 38, 37, 36, 35, 34, 32, 30, 28,
27, 26, 25, 24, 23, 22, 21, 20, 18, 17, 15, 14, 13, 12,
11, 10),
stringsAsFactors = FALSE
)
words <- keywords$word
freqs <- keywords$weight
names(freqs) <- words
# =====================================================================
# C. National colour scheme
# =====================================================================
national_palette <- c(
"black",        # ðŸ‡°ðŸ‡ª black
"#FF0000",      # ðŸ‡°ðŸ‡ª red
"#008000"       # ðŸ‡°ðŸ‡ª green
)
word_colors <- ifelse(words == "DSAS", "white", sample(national_palette, length(words), replace = TRUE))
# =====================================================================
# D. Word Cloud (BIG, dense, transparent PNG)
# =====================================================================
wc_png <- "wc_raw.png"
png(filename = wc_png,
width = 8000, height = 8000,
bg = "transparent", res = 600)
par(mar = c(0,0,0,0))
set.seed(222)
wordcloud(
words = names(freqs),
freq = freqs,
scale = c(10, 1.2),     # BIG and dense
min.freq = 1,
random.order = FALSE,
rot.per = 0,            # horizontal only (clean + professional)
colors = word_colors,
use.r.layout = FALSE
)
dev.off()
# =====================================================================
# E. Composite wordcloud into Kenya mask using magick
# =====================================================================
mask <- image_read(png_mask_path)
wc   <- image_read(wc_png)
mask_info <- image_info(mask)
wc_resized <- image_resize(wc,
paste0(mask_info$width, "x", mask_info$height, "!"))
mask_gray <- image_convert(mask, colorspace = "gray")
masked <- image_composite(
wc_resized, mask_gray,
operator = "DstIn"
)
# Strong outline using Kenya shape (black)
outline <- image_read(png_mask_path) %>%
image_colorize(opacity = 70, color = "black") %>%
image_blur(radius = 3, sigma = 2)
# Put outline behind masked words
final <- image_composite(outline, masked, operator = "Over")
# =====================================================================
# Save final
# =====================================================================
image_write(final, "kenya_wordcloud_composite.png", format = "png")
# 1. libraries
library(wordcloud)
library(RColorBrewer)
library(magick)
library(sf)
library(rnaturalearth)
# ------------------------------
# A. Ensure you have a proper Kenya mask:
# Create a white Kenya shape on transparent background (one-off)
# ------------------------------
kenya <- ne_countries(country = "Kenya", scale = "medium", returnclass = "sf")
# save a white-on-transparent mask file (PNG)
png_mask_path <- "kenya_mask_inverted.png"
png(filename = png_mask_path, width = 8000, height = 8000, bg = "transparent", res = 300)
par(mar = c(0, 0, 0, 0))
plot(st_geometry(kenya), col = "white", border = NA, axes = FALSE)
dev.off()
# ------------------------------
# B. Make high-res wordcloud with transparent background
#    using your keywords dataframe
# ------------------------------
# example keywords df (replace with your df if named differently)
keywords <- data.frame(
word = c(
"DSAS", "data", "analysis", "biostatistics", "modelling", "monitoring", "evaluation",
"bioinformatics", "predictive models", "machine learning", "algorithms", "design",
"reporting", "genomic", "proteomic", "database management", "data safeguarding",
"collection", "interpretation", "epidemiology", "disease trends", "automation",
"capacity building", "mentorship", "dissemination", "publications", "workshops",
"research support", "ensemble modelling", "computational tools"
),
weight = c(55, 50, 48, 45, 44, 40, 38, 37, 36, 35, 34, 32, 30, 28, 27, 26, 25, 24, 23, 22, 21, 20, 18, 17, 15, 14, 13, 12, 11, 10),
stringsAsFactors = FALSE
)
# Create a vector of words and freqs
words <- keywords$word
freqs <- keywords$weight
names(freqs) <- words
# Save wordcloud to PNG with transparent background
wc_png <- "wc_raw.png"
png(filename = wc_png, width = 8000, height = 8000, bg = "transparent", res = 300)
par(mar = c(0, 0, 0, 0))
set.seed(123)
# scale: c(max_scale, min_scale) â€” adjust to increase font sizes
wordcloud(names(freqs),
freq = freqs, scale = c(6, 0.6),
min.freq = 1, random.order = FALSE, rot.per = 0.08,
use.r.layout = FALSE,
colors = brewer.pal(8, "Dark2")
)
dev.off()
# ------------------------------
# C. Composite wordcloud into Kenya mask using magick
#    Keep only the parts of the wordcloud that fall inside the white shape.
# ------------------------------
mask <- image_read(png_mask_path) # white shape on transparent
wc <- image_read(wc_png) # the transparent wordcloud
# Resize the wordcloud to match mask size (if needed)
mask_info <- image_info(mask)
wc_resized <- image_resize(wc, paste0(mask_info$width, "x", mask_info$height, "!"))
# Convert mask to a proper alpha mask: the white area of the mask should be opaque
# Create a grayscale mask where white=opaque, transparent=transparent
mask_gray <- image_convert(mask, colorspace = "gray")
# Use the mask to keep only the wordcloud pixels inside the shape.
# Operator "DstIn" keeps destination (wordcloud) where mask non-transparent
masked <- image_composite(wc_resized, mask_gray, operator = "DstIn")
# Optional: if you want the map outline as a subtle stroke behind words,
# create a faint black silhouette from the mask and composite under the masked wordcloud
silhouette <- image_fill(mask, "black", fuzz = 0) %>% image_transparent("white")
silhouette <- image_modulate(silhouette, brightness = 40) # dark subtle background
final <- image_composite(silhouette, masked, operator = "Over")
# Save final
image_write(final, "kenya_wordcloud_composite.png", format = "png")
# -------------------------------------------------
# 1. Libraries
# -------------------------------------------------
library(wordcloud)
library(RColorBrewer)
library(magick)
library(sf)
library(rnaturalearth)
# -------------------------------------------------
# 2. Kenya mask (white Kenya polygon on transparent)
# -------------------------------------------------
kenya <- ne_countries(country = "Kenya", scale = "medium", returnclass = "sf")
mask_file <- "kenya_mask_white.png"
png(filename = mask_file, width = 8000, height = 8000, bg = "transparent", res = 300)
par(mar = c(0,0,0,0))
plot(st_geometry(kenya), col = "white", border = NA, axes = FALSE)
dev.off()
# -------------------------------------------------
# 3. Word list
# -------------------------------------------------
keywords <- data.frame(
word = c(
"DSAS","Data","Analytics","Biostatistics","Modelling","Monitoring","Evaluation",
"Bioinformatics","Predictive Models","Machine Learning","Algorithms","Study Design",
"Reporting","Genomics","Proteomics","Data Management","Safeguarding",
"Collection","Interpretation","Epidemiology","Disease Trends","Automation",
"Capacity Building","Mentorship","Dissemination","Publications","Workshops",
"Research Support","Ensemble Modelling","Computational Tools"
),
weight = c(60,55,52,50,48,46,44,42,40,38,36,34,32,30,29,28,27,26,25,24,23,22,20,18,16,15,14,13,12,11),
stringsAsFactors = FALSE
)
words <- keywords$word
freqs <- keywords$weight
names(freqs) <- words
# -------------------------------------------------
# 4. Raw wordcloud (transparent background)
# -------------------------------------------------
wc_file <- "wc_raw.png"
png(filename = wc_file, width = 8000, height = 8000, bg = "transparent", res = 300)
par(mar = c(0,0,0,0))
set.seed(42)
wordcloud(
words = names(freqs),
freq = freqs,
scale = c(9, 1.5),         # â† larger words
min.freq = 1,
random.order = FALSE,
rot.per = 0,               # â† all horizontal for readability
use.r.layout = TRUE,       # â† tighter packing
colors = brewer.pal(9, "Set1")
)
dev.off()
# -------------------------------------------------
# 5. Composite wordcloud inside Kenya shape
# -------------------------------------------------
mask <- image_read(mask_file)
wc <- image_read(wc_file)
# match dimensions
mask_info <- image_info(mask)
wc <- image_resize(wc, paste0(mask_info$width, "x", mask_info$height, "!"))
# convert mask to grey (white = keep, transparent = drop)
mask_grey <- image_convert(mask, colorspace = "gray")
# keep only wordcloud pixels inside shape
masked <- image_composite(wc, mask_grey, operator = "DstIn")
# -------------------------------------------------
# 6. Add a soft Kenya outline behind words
# -------------------------------------------------
outline <- image_fill(mask, "black", fuzz = 0)      # black silhouette
outline <- image_transparent(outline, "white")      # remove white
outline <- image_modulate(outline, brightness = 45) # faint background
final <- image_composite(outline, masked, operator = "Over")
# -------------------------------------------------
# 7. Save final image
# -------------------------------------------------
image_write(final, "kenya_wordcloud_final.png", format = "png")
final
print
print(final)
library(sf)
library(rnaturalearth)
library(ggplot2)
library(dplyr)
library(scales)
library(viridis)
set.seed(42)
# -------------------------------
# 1. Load Kenya polygon and project to metric (meters)
# -------------------------------
kenya <- ne_countries(country = "Kenya", scale = "medium", returnclass = "sf")
kenya_proj <- st_transform(kenya, 3857)
centroid <- st_coordinates(st_centroid(st_union(kenya_proj)))
# -------------------------------
# 2. Words and weights (example)
# -------------------------------
keywords <- data.frame(
word = c(
"data", "analysis", "biostatistics", "modelling",
"monitoring", "evaluation", "bioinformatics",
"predictive models", "machine learning", "algorithms",
"design", "reporting", "genomic", "proteomic",
"database management", "data safeguarding", "collection",
"interpretation", "epidemiology", "disease trends",
"automation", "capacity building", "mentorship",
"dissemination", "publications", "workshops",
"research support", "ensemble modelling", "computational tools"
),
weight = c(
50, 48, 45, 44,
40, 38, 37,
36, 35, 34,
32, 30, 28, 27,
26, 25, 24,
23, 22, 21,
20, 18, 17,
15, 14, 13,
12, 11, 10
),
stringsAsFactors = FALSE
)
# add DSAS as central and prominent
keywords <- rbind(
data.frame(word = "DSAS", weight = max(keywords$weight) + 10, stringsAsFactors = FALSE),
keywords
)
# -------------------------------
# 3. Size scaling (increase sizes here)
# -------------------------------
# Adjust these ranges if you want bigger/smaller words
min_size_pt <- 9 # smallest point size
max_size_pt <- 20 # largest point size (DSAS will be near this)
keywords <- keywords %>%
arrange(desc(weight)) %>%
mutate(size_pt = rescale(weight, to = c(min_size_pt, max_size_pt)))
n_words <- nrow(keywords)
# -------------------------------
# 4. Candidate points (sample inside Kenya)
#    Increase n_candidates if placement fails
# -------------------------------
n_candidates <- n_words * 700
cat("Generating", n_candidates, "candidate points inside Kenya (this may take a second)...\n")
cand_sfc <- st_sample(kenya_proj, size = n_candidates, type = "random")
cand_df <- data.frame(st_coordinates(cand_sfc))
colnames(cand_df) <- c("x", "y")
# -------------------------------
# 5. Helper: create rotated rectangle polygon at (cx,cy)
#    width and height are in meters; angle in degrees
# -------------------------------
make_rect <- function(cx, cy, width, height, angle = 0) {
# rectangle centered at origin
x0 <- c(-width / 2, width / 2, width / 2, -width / 2, -width / 2)
y0 <- c(-height / 2, -height / 2, height / 2, height / 2, -height / 2)
# rotate
a <- angle * pi / 180
rot <- matrix(c(cos(a), -sin(a), sin(a), cos(a)), nrow = 2)
pts <- t(rot %*% rbind(x0, y0))
pts[, 1] <- pts[, 1] + cx
pts[, 2] <- pts[, 2] + cy
list(matrix(c(pts[, 1], pts[, 2]), ncol = 2))
st_polygon(list(pts))
}
# -------------------------------
# 6. Text box sizing heuristic (meters)
#    You can tune these constants to fit your visual preference
#    width â‰ˆ size_pt * char_width * nchar(word)
#    height â‰ˆ size_pt * line_height
# -------------------------------
char_width_factor <- 2800 # meters per (point * character). Tweak if boxes too big/small
height_factor <- 2000 # meters per point for height
# -------------------------------
# 7. Placement loop (largest words first)
# -------------------------------
keywords <- keywords %>% arrange(desc(size_pt))
placed_polys <- list()
placed_meta <- list() # store centers, sizes, angles, etc.
# We'll try each word, scanning randomized candidate points.
# If a full-size box cannot be placed after X attempts, we try shrinking the box a little and retry.
max_attempts_per_word <- 1200
shrink_step <- 0.90 # reduce size by 10% each time if can't place
min_allowed_shrink <- 0.6 # do not shrink below 60% of original
for (i in seq_len(n_words)) {
w <- keywords$word[i]
size_pt <- keywords$size_pt[i]
nch <- nchar(w)
placed <- FALSE
attempts <- 0
current_size_pt <- size_pt
while (!placed) {
attempts <- attempts + 1
# precompute width & height for this size
width_m <- current_size_pt * nch * char_width_factor
height_m <- current_size_pt * height_factor
# try many random candidate points (shuffle)
cand_idx <- sample(nrow(cand_df), nrow(cand_df))
# allow only horizontal (0) or vertical (90)
for (j in cand_idx) {
cx <- cand_df$x[j]
cy <- cand_df$y[j]
# try horizontal then vertical for this candidate
angles_try <- c(0, 90)
for (angle in angles_try) {
rect_sfg <- make_rect(cx, cy, width_m, height_m, angle)
rect_sfc <- st_sfc(rect_sfg, crs = st_crs(kenya_proj))
# 1) must be fully within Kenya polygon
if (!as.logical(st_within(rect_sfc, kenya_proj, sparse = FALSE))) next
# 2) must not intersect any placed polygons
if (length(placed_polys) > 0) {
inter <- st_intersects(rect_sfc, st_sfc(placed_polys, crs = st_crs(kenya_proj)), sparse = FALSE)
if (any(inter)) next
}
# passed tests â†’ accept placement
placed_polys[[length(placed_polys) + 1]] <- rect_sfg
placed_meta[[length(placed_meta) + 1]] <- list(
word = w,
size_pt = current_size_pt,
angle = angle,
cx = cx, cy = cy,
width = width_m, height = height_m
)
placed <- TRUE
break
} # end angle loop
if (placed) break
} # end cand loop
if (!placed) {
# shrink and retry
current_size_pt <- current_size_pt * shrink_step
# if too small break (give up)
if (current_size_pt < size_pt * min_allowed_shrink) {
warning(sprintf("Could not place '%s' at reasonable size; placing at last-available location (may overlap).", w))
# as fallback, place randomly at any point inside Kenya without checking intersections
j <- sample(nrow(cand_df), 1)
cx <- cand_df$x[j]
cy <- cand_df$y[j]
angle <- sample(c(0, 90), 1)
rect_sfg <- make_rect(cx, cy, width_m, height_m, angle)
placed_polys[[length(placed_polys) + 1]] <- rect_sfg
placed_meta[[length(placed_meta) + 1]] <- list(
word = w,
size_pt = current_size_pt,
angle = angle,
cx = cx, cy = cy,
width = width_m, height = height_m
)
placed <- TRUE
}
}
if (attempts > max_attempts_per_word) {
warning(sprintf("Max attempts reached for '%s'. Moving on.", w))
break
}
} # end while
cat(sprintf("Placed %d/%d : %-20s size_pt=%.1f\n", i, n_words, w, placed_meta[[length(placed_meta)]]$size_pt))
}
# -------------------------------
# 8. Build placement dataframe for plotting (convert centers back to lon/lat)
# -------------------------------
meta_df <- do.call(rbind, lapply(placed_meta, function(x) {
data.frame(
word = x$word, size_pt = x$size_pt, angle = x$angle,
cx = x$cx, cy = x$cy, width = x$width, height = x$height, stringsAsFactors = FALSE
)
}))
meta_sf <- st_as_sf(meta_df, coords = c("cx", "cy"), crs = st_crs(kenya_proj))
meta_ll <- st_transform(meta_sf, st_crs(kenya))
coords_ll <- st_coordinates(meta_ll)
meta_df$xlon <- coords_ll[, 1]
meta_df$ylat <- coords_ll[, 2]
# color palette
meta_df$color <- ifelse(meta_df$word == "DSAS", "#000000", viridis(n_words)[seq_len(n_words)])
# order for plotting (DSAS first)
meta_df <- meta_df %>% arrange(desc(size_pt))
# -------------------------------
# 9. Plot map + text (no overlaps guaranteed by rectangle test)
# -------------------------------
p <- ggplot() +
geom_sf(data = kenya, fill = "#f8f8f8", color = NA) +
geom_text(
data = meta_df,
aes(x = xlon, y = ylat, label = word, angle = angle, color = color),
family = "Segoe UI", fontface = "bold",
size = meta_df$size_pt / 3.5, # scale point size for ggplot rendering (tune as needed)
lineheight = 0.9
) +
scale_color_identity() +
theme_void() +
theme(plot.background = element_rect(fill = "white", color = NA))
print(p)
# -------------------------------
# 10. Save
# -------------------------------
ggsave("kenya_wordcloud_no_overlap.png", p, width = 9, height = 9, dpi = 300)
cat("Done. PNG saved as 'kenya_wordcloud_no_overlap.png'.\n")
